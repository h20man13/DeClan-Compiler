SYMBOL SECTION
 ENTRY a INTERNAL PARAM n Abs 0
 ENTRY b INTERNAL RETURN Abs
 ENTRY c INTERNAL PARAM n RAbs 0
 ENTRY d INTERNAL RETURN RAbs
 ENTRY e INTERNAL PARAM n RealExp 0
 ENTRY f INTERNAL PARAM exp RealExp 1
 ENTRY g INTERNAL RETURN RealExp
 ENTRY h INTERNAL PARAM n IntExp 0
 ENTRY i INTERNAL PARAM exp IntExp 1
 ENTRY j INTERNAL RETURN IntExp
 ENTRY k INTERNAL PARAM n Floor 0
 ENTRY l INTERNAL RETURN Floor
 ENTRY m INTERNAL PARAM n Round 0
 ENTRY n INTERNAL RETURN Round
 ENTRY o INTERNAL PARAM n Ceil 0
 ENTRY p INTERNAL RETURN Ceil
 ENTRY q INTERNAL result Abs
 ENTRY u EXTERNAL PARAM INeg 0
 ENTRY v EXTERNAL RETURN INeg
 ENTRY x INTERNAL result RAbs
 ENTRY y INTERNAL intResult RAbs
 ENTRY z INTERNAL signBit RAbs
 ENTRY A EXTERNAL PARAM RealIsNegative 0
 ENTRY B EXTERNAL RETURN RealIsNegative
 ENTRY E EXTERNAL PARAM RNeg 0
 ENTRY F EXTERNAL RETURN RNeg
 ENTRY H INTERNAL result RealExp
 ENTRY I INTERNAL count RealExp
 ENTRY K EXTERNAL PARAM IntToReal 0
 ENTRY L EXTERNAL RETURN IntToReal
 ENTRY T EXTERNAL PARAM RMul 0
 ENTRY U EXTERNAL PARAM RMul 1
 ENTRY V EXTERNAL RETURN RMul
 ENTRY a5 EXTERNAL PARAM RDivide 0
 ENTRY a6 EXTERNAL PARAM RDivide 1
 ENTRY a7 EXTERNAL RETURN RDivide
 ENTRY b2 INTERNAL result IntExp
 ENTRY b3 INTERNAL count IntExp
 ENTRY b8 EXTERNAL PARAM RLessThan 0
 ENTRY b9 EXTERNAL PARAM RLessThan 1
 ENTRY c0 EXTERNAL RETURN RLessThan
 ENTRY c3 EXTERNAL PARAM Multiply 0
 ENTRY c4 EXTERNAL PARAM Multiply 1
 ENTRY c5 EXTERNAL RETURN Multiply
 ENTRY c9 EXTERNAL PARAM RAdd 0
 ENTRY d0 EXTERNAL PARAM RAdd 1
 ENTRY d1 EXTERNAL RETURN RAdd
 ENTRY d5 INTERNAL result Floor
 ENTRY d6 EXTERNAL PARAM RealToInt 0
 ENTRY d7 EXTERNAL RETURN RealToInt
 ENTRY d9 INTERNAL result Round
 ENTRY e0 INTERNAL additionResult Round
 ENTRY e4 EXTERNAL PARAM RSub 0
 ENTRY e5 EXTERNAL PARAM RSub 1
 ENTRY e6 EXTERNAL RETURN RSub
 ENTRY f1 INTERNAL result Ceil
DATA SECTION
PROC SECTION
 PROC LABEL Abs
  DEF q := 0 <INT>
  DEF r := 0 <INT>
  DEF s := (PARAM a) GE r <BOOL>
  DEF t := TRUE <BOOL>
  IF s BEQ t
  THEN IFSTAT_0_SEQ_0_LEVEL_0
  ELSE IFNEXT_0_SEQ_0_LEVEL_0
  LABEL IFSTAT_0_SEQ_0_LEVEL_0
  q := (PARAM a) <INT>
  GOTO IFEND_0_LEVEL_0
  LABEL IFNEXT_0_SEQ_0_LEVEL_0
  CALL INeg([(PARAM a) -> u]<INT>)
  DEF w := (RETURN v) <INT>
  q := w <INT>
  GOTO IFEND_0_LEVEL_0
  LABEL IFNEXT_0_SEQ_1_LEVEL_0
  LABEL IFEND_0_LEVEL_0
  DEF RETURN b := q <INT>
 RETURN
 PROC LABEL RAbs
  DEF x := 0.0 <REAL>
  DEF y := 0 <INT>
  DEF z := FALSE <BOOL>
  CALL RealIsNegative([(PARAM c) -> A]<REAL>)
  DEF C := (RETURN B) <BOOL>
  z := C <BOOL>
  DEF D := TRUE <BOOL>
  IF z BEQ D
  THEN IFSTAT_1_SEQ_0_LEVEL_0
  ELSE IFNEXT_1_SEQ_0_LEVEL_0
  LABEL IFSTAT_1_SEQ_0_LEVEL_0
  CALL RNeg([(PARAM c) -> E]<REAL>)
  DEF G := (RETURN F) <REAL>
  x := G <REAL>
  GOTO IFEND_1_LEVEL_0
  LABEL IFNEXT_1_SEQ_0_LEVEL_0
  LABEL IFEND_1_LEVEL_0
  DEF RETURN d := x <REAL>
 RETURN
 PROC LABEL RealExp
  DEF H := 0.0 <REAL>
  DEF I := 0 <INT>
  DEF J := 1 <INT>
  CALL IntToReal([J -> K]<INT>)
  DEF M := (RETURN L) <REAL>
  H := M <REAL>
  DEF N := 0 <INT>
  I := N <INT>
  DEF O := 0 <INT>
  DEF P := (PARAM f) GT O <BOOL>
  DEF Q := TRUE <BOOL>
  IF P BEQ Q
  THEN IFSTAT_2_SEQ_0_LEVEL_0
  ELSE IFNEXT_2_SEQ_0_LEVEL_0
  LABEL IFSTAT_2_SEQ_0_LEVEL_0
  DEF R := I LT (PARAM f) <BOOL>
  DEF S := TRUE <BOOL>
  IF R BEQ S
  THEN WHILESTAT_0_SEQ_0_LEVEL_0
  ELSE WHILENEXT_0_SEQ_0_LEVEL_0
  LABEL WHILECOND_0_SEQ_0_LEVEL_0
  IF R BEQ S
  THEN WHILESTAT_0_SEQ_0_LEVEL_0
  ELSE WHILEEND_0_LEVEL_0
  LABEL WHILESTAT_0_SEQ_0_LEVEL_0
  CALL RMul([H -> T]<REAL>, [(PARAM e) -> U]<REAL>)
  DEF W := (RETURN V) <REAL>
  H := W <REAL>
  DEF X := 1 <INT>
  DEF Y := I IADD X <INT>
  I := Y <INT>
  DEF Z := I LT (PARAM f) <BOOL>
  R := Z <BOOL>
  GOTO WHILECOND_0_SEQ_0_LEVEL_0
  LABEL WHILENEXT_0_SEQ_0_LEVEL_0
  LABEL WHILEEND_0_LEVEL_0
  GOTO IFEND_2_LEVEL_0
  LABEL IFNEXT_2_SEQ_0_LEVEL_0
  DEF a0 := 0 <INT>
  DEF a1 := (PARAM f) LT a0 <BOOL>
  DEF a2 := TRUE <BOOL>
  IF a1 BEQ a2
  THEN IFSTAT_2_SEQ_1_LEVEL_0
  ELSE IFNEXT_2_SEQ_1_LEVEL_0
  LABEL IFSTAT_2_SEQ_1_LEVEL_0
  DEF a3 := I GT (PARAM f) <BOOL>
  DEF a4 := TRUE <BOOL>
  IF a3 BEQ a4
  THEN WHILESTAT_2_SEQ_0_LEVEL_0
  ELSE WHILENEXT_2_SEQ_0_LEVEL_0
  LABEL WHILECOND_2_SEQ_0_LEVEL_0
  IF a3 BEQ a4
  THEN WHILESTAT_2_SEQ_0_LEVEL_0
  ELSE WHILEEND_2_LEVEL_0
  LABEL WHILESTAT_2_SEQ_0_LEVEL_0
  CALL RDivide([H -> a5]<REAL>, [(PARAM e) -> a6]<REAL>)
  DEF a8 := (RETURN a7) <REAL>
  H := a8 <REAL>
  DEF a9 := 1 <INT>
  DEF b0 := I ISUB a9 <INT>
  I := b0 <INT>
  DEF b1 := I GT (PARAM f) <BOOL>
  a3 := b1 <BOOL>
  GOTO WHILECOND_2_SEQ_0_LEVEL_0
  LABEL WHILENEXT_2_SEQ_0_LEVEL_0
  LABEL WHILEEND_2_LEVEL_0
  GOTO IFEND_2_LEVEL_0
  LABEL IFNEXT_2_SEQ_1_LEVEL_0
  LABEL IFEND_2_LEVEL_0
  DEF RETURN g := H <REAL>
 RETURN
 PROC LABEL IntExp
  DEF b2 := 0 <INT>
  DEF b3 := 0.0 <REAL>
  DEF b4 := 1 <INT>
  b2 := b4 <INT>
  DEF b5 := 0 <INT>
  CALL IntToReal([b5 -> K]<INT>)
  DEF b6 := (RETURN L) <REAL>
  b3 := b6 <REAL>
  CALL IntToReal([(PARAM i) -> K]<INT>)
  DEF b7 := (RETURN L) <REAL>
  CALL RLessThan([b3 -> b8]<REAL>, [b7 -> b9]<REAL>)
  DEF c1 := (RETURN c0) <BOOL>
  DEF c2 := TRUE <BOOL>
  IF c1 BEQ c2
  THEN WHILESTAT_4_SEQ_0_LEVEL_0
  ELSE WHILENEXT_4_SEQ_0_LEVEL_0
  LABEL WHILECOND_4_SEQ_0_LEVEL_0
  IF c1 BEQ c2
  THEN WHILESTAT_4_SEQ_0_LEVEL_0
  ELSE WHILEEND_4_LEVEL_0
  LABEL WHILESTAT_4_SEQ_0_LEVEL_0
  CALL Multiply([b2 -> c3]<INT>, [(PARAM h) -> c4]<INT>)
  DEF c6 := (RETURN c5) <INT>
  b2 := c6 <INT>
  DEF c7 := 1 <INT>
  CALL IntToReal([c7 -> K]<INT>)
  DEF c8 := (RETURN L) <REAL>
  CALL RAdd([b3 -> c9]<REAL>, [c8 -> d0]<REAL>)
  DEF d2 := (RETURN d1) <REAL>
  b3 := d2 <REAL>
  CALL IntToReal([(PARAM i) -> K]<INT>)
  DEF d3 := (RETURN L) <REAL>
  CALL RLessThan([b3 -> b8]<REAL>, [d3 -> b9]<REAL>)
  DEF d4 := (RETURN c0) <BOOL>
  c1 := d4 <BOOL>
  GOTO WHILECOND_4_SEQ_0_LEVEL_0
  LABEL WHILENEXT_4_SEQ_0_LEVEL_0
  LABEL WHILEEND_4_LEVEL_0
  DEF RETURN j := b2 <INT>
 RETURN
 PROC LABEL Floor
  DEF d5 := 0 <INT>
  CALL RealToInt([(PARAM k) -> d6]<REAL>)
  DEF d8 := (RETURN d7) <INT>
  d5 := d8 <INT>
  DEF RETURN l := d5 <INT>
 RETURN
 PROC LABEL Round
  DEF d9 := 0 <INT>
  DEF e0 := 0.0 <REAL>
  CALL RealIsNegative([(PARAM m) -> A]<REAL>)
  DEF e1 := (RETURN B) <BOOL>
  DEF e2 := TRUE <BOOL>
  IF e1 BEQ e2
  THEN IFSTAT_3_SEQ_0_LEVEL_0
  ELSE IFNEXT_3_SEQ_0_LEVEL_0
  LABEL IFSTAT_3_SEQ_0_LEVEL_0
  DEF e3 := 0.5 <REAL>
  CALL RSub([(PARAM m) -> e4]<REAL>, [e3 -> e5]<REAL>)
  DEF e7 := (RETURN e6) <REAL>
  e0 := e7 <REAL>
  GOTO IFEND_3_LEVEL_0
  LABEL IFNEXT_3_SEQ_0_LEVEL_0
  DEF e8 := 0.5 <REAL>
  CALL RAdd([(PARAM m) -> c9]<REAL>, [e8 -> d0]<REAL>)
  DEF e9 := (RETURN d1) <REAL>
  e0 := e9 <REAL>
  GOTO IFEND_3_LEVEL_0
  LABEL IFNEXT_3_SEQ_1_LEVEL_0
  LABEL IFEND_3_LEVEL_0
  CALL Floor([e0 -> k]<REAL>)
  DEF f0 := (RETURN l) <INT>
  d9 := f0 <INT>
  DEF RETURN n := d9 <INT>
 RETURN
 PROC LABEL Ceil
  DEF f1 := 0 <INT>
  CALL Floor([(PARAM o) -> k]<REAL>)
  DEF f2 := (RETURN l) <INT>
  DEF f3 := 1 <INT>
  DEF f4 := f2 IADD f3 <INT>
  f1 := f4 <INT>
  DEF RETURN p := f1 <INT>
 RETURN
